Java不是内存自动回收吗，怎么还会出现内存泄漏？
下面我们详细探讨下Java的GC机制：
  一：Jvm是如何判断一个对象是否应该被回收呢？
      这里有两种方式，引用计数法和引用可达分析法
        1、引用计数法：
            每一个对象，都有一个引用计数属性，当这个对象被引用一次，这个计数属性就加一，引用释放时，计数属性减一，当这个引用属性值为零时，就回收这个对象。
            但是，这里有一个问题，那就是对象循环引用的问题，假如，A引用了B，B也引用了A，那么他们的计数器都是1，都不会被回收；
            
        2、引用可达分析法：
            为避免引用计数法出现的问题，后来提出了引用可达法；从GC ROOT开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC ROOT没有任何引用链时，则证明
            此对象是不可用的，那么jvm就判断是可被回收的对象。
            那么GC ROOT 对象有哪些呢？
              1）、虚拟机栈中的引用对象
              2）、方法区中类静态属性的引用对象
              3）、方法区中常量的引用对象
              4）、本地方法栈中JNI的引用对象
    二：哪些情况会出现内存泄漏？
        既然有这么厉害的垃圾回收机制了，为什么还会出现内存泄漏呢？
        内存泄漏的定义：  内存泄漏是指一个不再被程序使用的对象或变量一直占据着内存。
         有可能此对象已经不使用了，但是还有其它对象保持着此对象的引用，就会导致 GC 不能回收此对象，这种情况下就会出现内存泄漏。
        第一种情况：
                长生命周期的对象持有短生命周期的对象的引用就可能发生内存泄漏，尽管短生命周期的对象已经不被使用了，但是因为长生命周期的对象持有它的引用，
                而导致它不能被回收。
                public class Simple{
                   Object obj;
                   public void method(){
                      obj = new Object();
                       //其他代码
                   }
                }
                这里的obj实例，其实我们只希望它作用于method方法中，但是，method方法执行完成后，obj不会被释放，只有Simeple对象释放时，才会释放。
                解决方法就是让他作为method的局部变量：
                public class Simeple{
                   Object obj;
                   public void method(){
                       obj = new Object();
                       //...
                       obj = null;
                   }
                }
                
           第二种情况：
                 集合中的内存泄漏，比如HashMap，ArrayList等，这些对象经常发生内存泄漏，比如当它们被声明为静态变量时，他们的声明周期就会和程序的
                 生命周期一样长了，很容易造成内存泄露；
                 Vector v = new Vector(10);
                 for(int i=0;i<10;i++){
                    Object o = new Object();
                    v.add(o)
                    o = null;
                 }//此时所有对象都没有被释放，因为变量v引用这些对象；
                 
                 在这个例子中，我们循环申请 Object 对象，并将所申请的对象放入一个 Vector 中，如果我们仅仅释放引用本身，那么 Vector 仍然引用该对象，所以这个对象对 GC 来说是不可回收的。

                 因此，如果对象加入到 Vector 后，还必须从 Vector 中删除，最简单的方法就是将 Vector 对象设置为 null。
                 
                 
                 
